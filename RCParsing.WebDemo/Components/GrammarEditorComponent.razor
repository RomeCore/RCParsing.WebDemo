@using RCParsing.WebDemo.Parsers
@inject IJSRuntime JS

<StandaloneCodeEditor @ref="editor"
Id="grammar-code-editor"
OnDidChangeModel="OnChange"
OnDidChangeModelContent="OnChange"
ConstructionOptions="EditorConstructionOptions" />

@code {
	#nullable disable

	private StandaloneCodeEditor editor;
	public Parser parser;
	public Exception exception;
	public Action OnParseStateChanged;
	public bool detailedMessages, stackTraces, walkTrace;

	private StandaloneEditorConstructionOptions EditorConstructionOptions(StandaloneCodeEditor editor)
	{
		return new StandaloneEditorConstructionOptions
			{
				AutomaticLayout = true,
				Theme = "vs-dark",
				Minimap = new EditorMinimapOptions { Enabled = false },
				SmoothScrolling = true,
				Language = "sbnf"
			};
	}

	protected async override Task OnAfterRenderAsync(bool firstRender)
	{
		await base.OnAfterRenderAsync(firstRender);
		await JS.InvokeVoidAsync("register_lang", "sbnf");
	}

	private bool _flag;

	private async Task SetErrors(IEnumerable<ErrorGroup> errors)
	{
		var model = await editor.GetModel();
		var markers = new List<MarkerData>();

		foreach (var error in errors)
		{
			var message = "Expected one of:\n" + error.Expected.Tokens.ToString().Indent("  ");

			markers.Add(new MarkerData
				{
					Severity = MarkerSeverity.Error,
					Message = message,
					StartLineNumber = error.Line,
					EndLineNumber = error.Line,
					StartColumn = error.Column,
					EndColumn = error.Column + 1
				});
		}

		await BlazorMonaco.Editor.Global.SetModelMarkers(JS, model, "owner", markers);
		await editor.SetModel(model);
	}

	private async Task RemoveError()
	{
		var model = await editor.GetModel();
		var markers = new List<MarkerData>();
		await BlazorMonaco.Editor.Global.SetModelMarkers(JS, model, "owner", markers);
		await editor.SetModel(model);
	}

	public async Task SetContents(string contents)
	{
		await editor.SetValue(contents);
	}

	public async Task Update()
	{
		try
		{
			var content = await editor.GetValue();

			var builder = new ParserBuilder();
			SBNFParser.ImportFrom(content, builder);

			if (detailedMessages)
				builder.Settings.DetailedErrors();
			if (stackTraces)
				builder.Settings.WriteStackTrace();
			if (walkTrace)
				builder.Settings.SetMaxStepsToDisplay(-1).RecordWalkTrace();

			parser = builder.Build();

			exception = null;
			OnParseStateChanged?.Invoke();
			await RemoveError();
		}
		catch (ParsingException ex)
		{
			exception = null;
			OnParseStateChanged?.Invoke();
			await SetErrors(ex.Groups.RelevantGroups);
		}
		catch (Exception ex)
		{
			exception = ex;
			OnParseStateChanged?.Invoke();
			await RemoveError();
		}
	}

	private async Task OnChange()
	{
		if (_flag) return;
		_flag = true;

		await Update();

		_flag = false;
	}
}